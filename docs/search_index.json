[["working-with-variables.html", "2 Working with variables 2.1 Strings 2.2 Factors 2.3 Dates 2.4 Dataframe variables Resources Exercises", " 2 Working with variables In virtually all studies, the data preparation process involves computing new variables or modifying some of the existing ones. The operations needed to modify an existing variable, or to create a new one, are typically dependent on the type of the input variable(s). For instance, numerical variables (such as the body weight and height) may be used to compute another numeric variable (the body mass index) with some formula; factors (such as the study site in multicentric studies) are often used to create a new variable (such as region or country) using some classification algorithm; and character variables (like symptoms) may require homogenization tasks (such as capitalization or elimination of whitespaces). It is therefore important to know what are the tools available to work with different types of variables, and how to use them. In this chapter, we will see how to perform the most common operations on character vectors (or strings), factors and dates. 2.1 Strings Strings of characters are almost always found among the data collected in a clinical study. The description of symptoms, signs, diseases, adverse events and treatments are examples of textual data. These kind of data is often encoded using controlled vocabularies, like ICD-9 or ICD-10 for diseases, MedDRA for adverse events, or ATC for drugs. However, proper encoding using these vocabularies is a non-trivial task that requires a very good knowledge of the coding vocabulary, and it is not always affordable or cost-effective, particularly in small studies. In addition, there is not always a controlled vocabulary available for the textual data at hand. For these reasons, working with strings is a common need in clinical and other type of studies. Although base R has functions to work with character vectors, we will give preference to those in package stringr, which is part of teh tidyverse. So, let’s start by loading this package: library(tidyverse) 2.1.1 Whitespaces and capitalization When working with real data, we will often find character vectors having semantically equivalent, but nonetheless different elements, due to whitespaces and capitalization. Consider the following character vector: x &lt;- c(&quot;Arterial hypertension&quot;, &quot;arterial hypertension&quot;, &quot;ARTERIAL HYPERTENSION&quot;, &quot;arterial hypertension &quot;, &quot;arterial hypertension &quot;, &quot;Pneumonia&quot;, &quot;pneumonia&quot;, &quot; pneumonia&quot;) x ## [1] &quot;Arterial hypertension&quot; &quot;arterial hypertension&quot; ## [3] &quot;ARTERIAL HYPERTENSION&quot; &quot;arterial hypertension &quot; ## [5] &quot;arterial hypertension &quot; &quot;Pneumonia&quot; ## [7] &quot;pneumonia&quot; &quot; pneumonia&quot; Although only two conditions appear in x (arterial hypertension and pneumonia), a frequency table of this vector will be less than satisfying, because all elements are actually different: some are lowercase, others contain uppercase letters, and some contain extra whitespaces (at the beginning, at the end, or between words): data.frame(x) %&gt;% count(x) ## x n ## 1 pneumonia 1 ## 2 arterial hypertension 1 ## 3 arterial hypertension 1 ## 4 Arterial hypertension 1 ## 5 ARTERIAL HYPERTENSION 1 ## 6 arterial hypertension 1 ## 7 pneumonia 1 ## 8 Pneumonia 1 Because R is case sensitive, \"Arterial hypertension\" is not the same as \"arterial hypertension\". In addition, it is important to be aware that a white space (or blank) is a character in its own right, and therefore these two strings are different because of a trailing blank in the second one: &quot;arterial hypertension&quot; == &quot;arterial hypertension &quot; ## [1] FALSE Function str_trim() removes white spaces at the beginning or at the end of a string: str_trim(x) ## [1] &quot;Arterial hypertension&quot; &quot;arterial hypertension&quot; ## [3] &quot;ARTERIAL HYPERTENSION&quot; &quot;arterial hypertension&quot; ## [5] &quot;arterial hypertension&quot; &quot;Pneumonia&quot; ## [7] &quot;pneumonia&quot; &quot;pneumonia&quot; In the result above, elements two and four of x are still different, because the later has more than one white space between the two words. Function str_squish() not only removes leading and trailing white spaces, but also reduces repeated white spaces inside a string: str_squish(x) ## [1] &quot;Arterial hypertension&quot; &quot;arterial hypertension&quot; &quot;ARTERIAL HYPERTENSION&quot; ## [4] &quot;arterial hypertension&quot; &quot;arterial hypertension&quot; &quot;Pneumonia&quot; ## [7] &quot;pneumonia&quot; &quot;pneumonia&quot; After getting rid of white spaces, we can use any of the following functions to homogenize case: str_to_lower(), str_to_upper(), str_to_title() or str_to_sentence(). Here we use the last one (but you can try with the other three): x %&gt;% str_squish() %&gt;% # removes leading, trailing and repeated blanks str_to_sentence() # capitalizes the first letter ## [1] &quot;Arterial hypertension&quot; &quot;Arterial hypertension&quot; &quot;Arterial hypertension&quot; ## [4] &quot;Arterial hypertension&quot; &quot;Arterial hypertension&quot; &quot;Pneumonia&quot; ## [7] &quot;Pneumonia&quot; &quot;Pneumonia&quot; The two conditions appearing in x have now a homogeneous spelling, so that a decent frequency table can be produced, as shown below. In the scripts above we started working with an isolated character vector (x) . But what if this is a variable in a dataframe? The same functions can be used (and chained!) within a mutate statement to compute a new version of x: d &lt;- data.frame(x) d ## x ## 1 Arterial hypertension ## 2 arterial hypertension ## 3 ARTERIAL HYPERTENSION ## 4 arterial hypertension ## 5 arterial hypertension ## 6 Pneumonia ## 7 pneumonia ## 8 pneumonia d %&gt;% mutate(x = x %&gt;% str_squish() %&gt;% str_to_sentence()) %&gt;% count(x) # frequency table of x values ## x n ## 1 Arterial hypertension 5 ## 2 Pneumonia 3 Now the frequency table looks as it should. 2.1.2 Matching, locating and replacing patterns Sometimes we will need to match some defined pattern in a character vector, with any of these purposes: Detect which elements in the vector match the pattern. Locate the position at which the pattern occurs in each element of the vector. Replace the pattern with an alternative text. Count how many times a pattern appears in each element of the vector. Functions str_detect(), str_locate(), str_replace(), and str_count() serve these four purposes, respectively. In all three functions, a pattern argument has to be specified. Consider the following vector describing the medical antecedents of 3 patients: x &lt;- c(&quot;diabetes mellitus&quot;, &quot;asthma&quot;, &quot;bronchial asthma + DM.&quot;) x ## [1] &quot;diabetes mellitus&quot; &quot;asthma&quot; &quot;bronchial asthma + DM.&quot; Suppose we want to identify patients with bronchial asthma. Patients 2 and 3 have different descriptors, but both contain “asthma”. Function str_detect() will tell us which elements in x contain “asthma”, by returning a logical vector the same length of x, with TRUE when the pattern is detected or FALSE otherwise: str_detect(x, pattern = &quot;asthma&quot;) ## [1] FALSE TRUE TRUE In some cases we may need to know what are the positions where a pattern is found. This can be achieved with function str_locate(). Note the result is a matrix with as many rows as elements in x, and two columns indicating the start-ing and end-ing positions of the pattern (or NA for non-matching elements in x). str_locate(x, &quot;asthma&quot;) ## start end ## [1,] NA NA ## [2,] 1 6 ## [3,] 11 16 Now suppose we want to replace “DM” by the full description “diabetes mellitus”. This can be done with str_replace(), specifying the pattern to be replaced and the replacement text: str_replace(x, pattern = &quot;DM&quot;, replacement = &quot;diabetes mellitus&quot;) ## [1] &quot;diabetes mellitus&quot; ## [2] &quot;asthma&quot; ## [3] &quot;bronchial asthma + diabetes mellitus.&quot; Last, str_count()counts the number of appearances of the pattern in each element of the input vector: x &lt;- c(&quot;I&quot;, &quot;II&quot;, &quot;III.&quot;, &quot;IV&quot;) str_count(x, pattern = &quot;I&quot;) ## [1] 1 2 3 1 The previous examples worked because the specified patterns contain letters only. However, when the pattern contains special characters, such as the dot, this will produce an error or unexpected results, as in this case: str_detect(x, pattern = &quot;.&quot;) ## [1] TRUE TRUE TRUE TRUE The reason for the previous result is that, by default, str_detect() expects the pattern to be specified as a regular expression. Regular expression are introduced in the next section, but for the time being, a turnaround is to use the helper function fixed() to specify the pattern literally (or coll() for languages other than English, see ?fixed). Now the result is as expected: str_detect(x, pattern = fixed(&quot;.&quot;)) ## [1] FALSE FALSE TRUE FALSE 2.1.3 Regular expressions Regular expressions (shortened as regex or regexp) provide a very flexible and concise way to specify complex patterns in strings through the use of symbols with special meaning called meta characters. These are listed in table 2.1 and examples of use follow. Table 2.1: Meta characters used in regular expressions Meta character Meaning . Matches any single character, except a line break | Matches the previous or the next characters ^ Denotes the begining of the string $ Denotes the end of the string [ ] Matches any character contained between them [^ ] Matches any character NOT contained between them ( ) Matches the characters contained between them in exact order ? Makes the preceeding optional * Matches 0 or more repetitions of the preceeding + Matches 1 or more repetitions of the preceeding {n} Matches exactly n repetitions of the preceeding {n,m} Matches a minimum of “n” and a maximum of “m” repetitions of the preceding \\ Escapes the next character The period . is used as a wildcard. Here we use it to match not only \"diabetes\", but also the misspelled \"diabetis\": x &lt;- c(&quot;diabetes mellitus&quot;, &quot;diabetis&quot;, &quot;DM&quot;, &quot;non-diabetic&quot;, &quot;carotid stenosis&quot;) str_detect(x, pattern = &quot;diabet.s&quot;) ## [1] TRUE TRUE FALSE FALSE FALSE The vertical bar | is used to specify alternative patterns (read it as or) to be matched. Here we use it to match “diabet.s” or the abbreviation for diabetes mellitus, “DM”: str_detect(x, pattern = &quot;diabet.s|DM&quot;) ## [1] TRUE TRUE TRUE FALSE FALSE The caret ^ and the dollar $ are used as anchors, to indicate the begining and the end of the string, respectively. Here we use them to identify drug families (cephalosporins and monoclonal antibodies): x &lt;- c(&quot;cefaclor&quot;, &quot;cefixime&quot;, &quot;diphenhydramine acefyllinate&quot;) str_detect(x, pattern = &quot;^cef&quot;) ## [1] TRUE TRUE FALSE x &lt;- c(&quot;omalizumab&quot;, &quot;reslizumab&quot;, &quot;mabuterol&quot;) str_detect(x, pattern = &quot;mab$&quot;) ## [1] TRUE TRUE FALSE Square brackets [] are used to specify a class of characters, so that any character in the class will be matched. Classes can be specified by a sequence of characters, as in [abc], [ABC] or [123], or using the dash to indicate a range, as in [a-z], [A-Z], or [0-9]. In the following example we use function str_extract() to get the doses and units from character vector x. The + is a quantifier, indicating to pick the pevious one or more times (try without the + to see the difference): x &lt;- c(&quot;250 mg&quot;, &quot;500mg&quot;, &quot;1 g&quot;, &quot;1gram&quot;, &quot;250 MG&quot;) str_extract(x, pattern = &quot;[0-9]+&quot;) # any number ## [1] &quot;250&quot; &quot;500&quot; &quot;1&quot; &quot;1&quot; &quot;250&quot; str_extract(x, pattern = &quot;[a-zA-Z]+&quot;) # any alphabetic character ## [1] &quot;mg&quot; &quot;mg&quot; &quot;g&quot; &quot;gram&quot; &quot;MG&quot;   Some classes of characters are so common that they are given special names: str_extract(x, pattern = &quot;[:digit:]+&quot;) # same as &quot;[0-9]+&quot; ## [1] &quot;250&quot; &quot;500&quot; &quot;1&quot; &quot;1&quot; &quot;250&quot; str_extract(x, pattern = &quot;[:alpha:]+&quot;) # same as &quot;[a-zA-Z]+&quot; ## [1] &quot;mg&quot; &quot;mg&quot; &quot;g&quot; &quot;gram&quot; &quot;MG&quot; When the caret ^ is used within [], it means negation, that is, to match any character not in the specified class. For instance, in the following script, we first extract roman numerals I to IV from vector nyha, and then we extract anything which is not one of them: nyha &lt;- c(&quot;I. No limitation in normal physical activity&quot;, &quot;II. Mild symptoms only in normal activity&quot;, &quot;III. Marked symptoms during daily activities, asymptomatic only at rest&quot;, &quot;IV. Severe limitations, symptoms even at rest&quot;) str_extract(nyha, pattern = &quot;[IV]+&quot;) # any I or V ## [1] &quot;I&quot; &quot;II&quot; &quot;III&quot; &quot;IV&quot; str_extract(nyha, pattern = &quot;[^IV]+&quot;) # anything different from I and V ## [1] &quot;. No limitation in normal physical activity&quot; ## [2] &quot;. Mild symptoms only in normal activity&quot; ## [3] &quot;. Marked symptoms during daily activities, asymptomatic only at rest&quot; ## [4] &quot;. Severe limitations, symptoms even at rest&quot; Brackets () are used to define a group of characters in the specified sequence. For instance, suppose we want to extract the units from vector x. Note the difference with square brackets: x ## [1] &quot;250 mg&quot; &quot;500mg&quot; &quot;1 g&quot; &quot;1gram&quot; &quot;250 MG&quot; str_detect(x, pattern = &quot;[mg]&quot;) # match any m or g, lowercase ## [1] TRUE TRUE TRUE TRUE FALSE str_detect(x, pattern = &quot;(mg)&quot;) # match the sequence &quot;mg&quot; ## [1] TRUE TRUE FALSE FALSE FALSE The question mark ? is used to make the preceeding optional. Here we use it to match two alternative spellings of some words: x &lt;- c(&quot;haemorrhage&quot;, &quot;hemorrhage&quot;, &quot;hemoglobin decreased&quot;, &quot;haemoglobin decreased&quot;) str_detect(x, pattern = &quot;ha?emo&quot;) ## [1] TRUE TRUE TRUE TRUE Braces {} are used to define number of repetitions, either exact, or in an interval: x &lt;- c(&quot;AMI in 2019&quot;, &quot;Born in 1989&quot;, &quot;Pulse 75 bpm&quot;) str_extract(x, pattern=&quot;[0-9]{4}&quot;) # exactly four digits ## [1] &quot;2019&quot; &quot;1989&quot; NA x &lt;- c(&quot;500 mg/24h&quot;, &quot;1000 mg/24h&quot;, &quot;week 1: 750 mg daily&quot;) str_extract(x, pattern=&quot;[0-9]{3,4}&quot;) # between three and four digits ## [1] &quot;500&quot; &quot;1000&quot; &quot;750&quot; The asterisk * allows to match any number of repetitions of an optional part: x &lt;- c(&quot;ab&quot;, &quot;aab&quot;, &quot;aaaab&quot;, &quot;b&quot;, &quot;c&quot;) str_detect(x, pattern=&quot;a*b&quot;) ## [1] TRUE TRUE TRUE TRUE FALSE Last, the backslash (\\) allows to remove the special meaning of meta characters, when we need to match them literally. However, because the backslash is a meta character itself, we need to remove its special meaning with another backslash, so that wee need to write two of them: x &lt;- c(&quot;asthma&quot;, &quot;astha + DM&quot;, &quot;AHT + hyperlipidemia&quot;) str_detect(x, &quot;\\\\+&quot;) ## [1] FALSE TRUE TRUE Working with regular expressions is challenging, particularly as they increase in complexity, and a useful trick is to visualize the matches they produce. A couple of functions help with this: str_view() shows the first match, and str_view_all() shows all matches: x &lt;- c(&quot;haemorrhage&quot;, &quot;hemorrhage and hemoglobin decreased&quot;, &quot;haemoglobin decreased&quot;) str_view(x, pattern = &quot;ha?emo&quot;) str_view_all(x, pattern = &quot;ha?emo&quot;) 2.1.4 Subsetting strings When we need to extract a specific part of a string defined by its position, function str_sub() is the way to go. Consider for instance the CIP codes, the unique personal identifier used by the Catalan Healthcare System, composed by 14 characters with the following structure: “iiiisyymmddxxx”, where “iiii” are surname initials, “s” is a code for sex (0: men, 1:female), “yymmdd” is the birth date, and “xxx” are three random numbers. Here we extract different parts of the CIP code based on start and end positions: x &lt;- c(&quot;FEGA0720525000&quot;, &quot;ROMA1680913000&quot;, &quot;PEJI0590503&quot;) str_sub(x, start = 5, end = 5) # extracts sex code ## [1] &quot;0&quot; &quot;1&quot; &quot;0&quot; str_sub(x, start = 6, end = 7) # extracts year of birth ## [1] &quot;72&quot; &quot;68&quot; &quot;59&quot; str_sub(x, start = 6, end = 11) # extracts birthdate ## [1] &quot;720525&quot; &quot;680913&quot; &quot;590503&quot; 2.1.5 Other useful functions Function str_length() finds the number of characters for each element of the input vector: x &lt;- c(&quot;DM&quot;, &quot;AHT&quot;) str_length(x) ## [1] 2 3 Sometimes we may want to collapse all the elements of a character vector into a single string (a character vector of length one). This can be done with str_flatten(): str_flatten(x, collapse = &quot; and &quot;) ## [1] &quot;DM and AHT&quot; With str_glue() we can easily compose texts, inserting values as needed, which may be useful to produce narrative reports. Note the use of str_flatten() to define antecedents: pid &lt;- 10 age &lt;- 58 sex &lt;- &quot;male&quot; antecedents &lt;- str_flatten(x, collapse = &quot; and &quot;) adverse_event &lt;- &quot;cephalea&quot; study_day &lt;- 3 str_glue(&quot;Patient number {pid}, a {age}y {sex} with {antecedents}, reported {adverse_event} on study day {study_day}.&quot;) ## Patient number 10, a 58y male with DM and AHT, ## reported cephalea on study day 3. Function str_split() splits up a string into pieces by defining a pattern used as separator, and returns a list the same length of the input vector. In the following example we split antecedents of a patient separated by a +. We need to use the (double) backslash in pattern to refer to literal +, and not to meta character +: x &lt;- c(&quot;asthma&quot;, &quot;astha + DM&quot;, &quot;DM + AHT + hyperlipidemia&quot;) str_split(x, pattern = &quot;\\\\+&quot;) ## [[1]] ## [1] &quot;asthma&quot; ## ## [[2]] ## [1] &quot;astha &quot; &quot; DM&quot; ## ## [[3]] ## [1] &quot;DM &quot; &quot; AHT &quot; &quot; hyperlipidemia&quot; The result is a list of character vectors, each having as many elements as antecedents. We can use the option simplify = TRUE to get the result as a matrix instead, with as many rows as elements in the input vector, and as many columns as the maximum number of antecedents, three in this example. In this case, some entries will be empty for patients with less than three antecedents: str_split(x, pattern = &quot;\\\\+&quot;, simplify = TRUE) ## [,1] [,2] [,3] ## [1,] &quot;asthma&quot; &quot;&quot; &quot;&quot; ## [2,] &quot;astha &quot; &quot; DM&quot; &quot;&quot; ## [3,] &quot;DM &quot; &quot; AHT &quot; &quot; hyperlipidemia&quot; Function str_sort() will sort the elements of a character vector alphabetically, unless we use option numeric=TRUE: x &lt;- c(&quot;10 mg&quot;, &quot;5 mg&quot;, &quot;2.5 mg&quot;) str_sort(x, numeric = TRUE) ## [1] &quot;2.5 mg&quot; &quot;5 mg&quot; &quot;10 mg&quot; 2.2 Factors Package forcats, which is part of the tidyverse, has functions to address common needs when working with factors. To illustrate some of these functions we will use the DISETHAE data introduced in the previous chapter. Here we read the data and define a factor for the categorical variable region: library(readxl) ah &lt;- read_excel(&quot;./data/hta.xlsx&quot;, sheet = &quot;data&quot;) %&gt;% mutate(region = factor(region, levels = 1:17, labels = c(&quot;Andalucía&quot;, &quot;Aragón&quot;, &quot;Asturias&quot;, &quot;Baleares&quot;, &quot;Canarias&quot;, &quot;Cantabria&quot;, &quot;Castilla-La Mancha&quot;, &quot;Castilla-León&quot;, &quot;Catalunya&quot;, &quot;Extremadura&quot;, &quot;Galicia&quot;, &quot;La Rioja&quot;, &quot;Madrid&quot;, &quot;Murcia&quot;, &quot;Navarra&quot;, &quot;País Vasco&quot;, &quot;Valencia&quot;))) 2.2.1 Reordering levels Suppose we want to produce a bar chart to see the number of patients recruited in each region. Here we use function gf_barh() from ggformula to produce a horizontal barchart: library(ggformula) gf_barh(~region, data = ah) We could make the bar chart more readable if regions were sorted by frequency. This is precisely the purpose of fct_infreq(): gf_barh(~fct_infreq(region), data = ah, ylab = &quot;Regions&quot;) To sort them in descending frequency we can use fct_rev(), which reverses the order of the levels of a factor. Note how we pipe this function after fct_infreq(region): gf_barh(~fct_infreq(region) %&gt;% fct_rev(), data = ah, ylab = &quot;Regions&quot;) Sometimes we may want to order the levels of a factor by some other variable. For instance, suppose we want to explore the mean age of patients in each region. To this end, we first group by region to compute the mean for each region, ungoup, and finally produce a graphic showing mean ages by region: ah %&gt;% group_by(region) %&gt;% summarize(mean_age = mean(age)) %&gt;% ungroup() %&gt;% gf_point(region ~ mean_age) Again, this would be much more readable with regions sorted by the mean age. This can be done by passing variable mean_age as second argument to function fct_reorder(): ah %&gt;% group_by(region) %&gt;% summarize(mean_age = mean(age)) %&gt;% ungroup() %&gt;% gf_point(fct_reorder(region, mean_age) ~ mean_age, ylab = &quot;Regions&quot;) 2.2.2 Modifying levels Changing the levels of a factor may be motivated by several reasons, such as providing better names, or grouping some levels into broader categories. There are several functions available in forcats to change the levels of a factor, some of which are very specialized. The most flexible one is fct_recode(). Here we use it to rename some of the regions according to official names. Note that new names are equated to old names (in this order), and that levels not mentioned will remain unchanged: ah %&gt;% mutate(region = fct_recode(region, &quot;Principado de Asturias&quot; = &quot;Asturias&quot;, &quot;Comunidad Foral de Navarra&quot; = &quot;Navarra&quot;, &quot;Comunitat Valenciana&quot; = &quot;Valencia&quot;, &quot;Castilla y León&quot; = &quot;Castilla-León&quot;, &quot;Cominudad de Madrid&quot; = &quot;Madrid&quot;)) %&gt;% gf_barh(~fct_infreq(region) %&gt;% fct_rev(), ylab = &quot;Regions&quot;) If we need to group levels into broader categories, str_collapse() is useful, as shown in the script below. In the second argument to this function, each new (broader) level is equated to a vector of (old) levels. Again, note that levels not mentioned are kept unchanged (“Canarias” still appears in the plot since it is not classified in any of the new broader regions). ah %&gt;% mutate(region = fct_collapse(region, &quot;North&quot; = c(&quot;Galicia&quot;, &quot;Asturias&quot;, &quot;Cantabria&quot;, &quot;País Vasco&quot;, &quot;Navarra&quot;, &quot;La Rioja&quot;, &quot;Aragón&quot;), &quot;East&quot; = c(&quot;Catalunya&quot;, &quot;Valencia&quot;, &quot;Murcia&quot;), &quot;South&quot; = &quot;Andalucía&quot;, &quot;Middle-West&quot; = c(&quot;Castilla-La Mancha&quot;, &quot;Castilla-León&quot;, &quot;Madrid&quot;, &quot;Extremadura&quot;))) %&gt;% gf_barh(~fct_infreq(region) %&gt;% fct_rev(), ylab = &quot;Regions&quot;) Sometimes we may need to collapse the levels of a factor which are less represented in the data. Suppose this is the distribution of the number of patients recruited in a clinical trial: d &lt;- data.frame(center = factor(paste(&quot;Hospital&quot;,rep(LETTERS[1:8], times = c(51, 26, 4, 5, 6, 32, 16, 6))))) d %&gt;% gf_barh(~center %&gt;% fct_rev(), ylab = &quot;&quot;) In such a case, we may want to pool small centers before analysis to avoid a large imbalance of centers. If none of its optional arguments is used, fct_lump() will pool smaller centers ensuring that the frequency of the pool will be lower than the remaining (unpooled) centers: d %&gt;% gf_barh(~fct_lump(center) %&gt;% fct_infreq() %&gt;% fct_rev(), ylab = &quot;&quot;) Not very useful in this case, since the Other class only contains hospital C. However, we can controll how the pooling is done using one of the two optional arguments n or prop. With n we can state how many centers should be kept unpooled. With prop we can indicate that centers with a frequency lower than prop should be pooled: d %&gt;% gf_barh(~fct_lump(center, n = 4) %&gt;% fct_infreq() %&gt;% fct_rev(), ylab = &quot;&quot;) d %&gt;% gf_percentsh(~fct_lump(center, prop = .15) %&gt;% fct_infreq() %&gt;% fct_rev(), ylab = &quot;&quot;) By default, the pool is named “Other”, but the optional argument other_level allows to specify a different name: d %&gt;% gf_barh(~fct_lump(center, n = 4, other_level = &quot;Small centers&quot;) %&gt;% fct_rev(), ylab = &quot;&quot;) 2.2.3 Ordered factors A special type of factors are ordered factors. The concept of an ordered factor may be a bit confusing, because the levels of a (regular) factor are always defined in a certain order, which affects how they are displayed in outputs like frequency tables or graphics. So, what is the point of ordered factors? In fact, the most important reason is their use in statistical models, which is different for (regular) factors and ordered factors. Ordered factors can be defined with function ordered(), a variation of factor(). Consider the following example, where we create both a (regular) factor and an ordered factor from a character vector of NYHA classes. You will note that, when printed to the console, the levels of nyha_1 and nyha_2 are displayed in a slightly different way (Levels: I II III IV and Levels: I &lt; II &lt; III &lt; IV, respectively): nyha &lt;- sample(c(&quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;), 10, replace = TRUE) nyha_1 &lt;- factor(nyha) # defines a (regular) factor nyha_2 &lt;- ordered(nyha) # defines an ordered factor nyha_1 ## [1] I III IV I II II IV I IV IV ## Levels: I II III IV nyha_2 ## [1] I III IV I II II IV I IV IV ## Levels: I &lt; II &lt; III &lt; IV   In addition, the class of nyha_2 is not just \"factor\", but \"ordered\" as well: class(nyha_1) ## [1] &quot;factor&quot; class(nyha_2) ## [1] &quot;ordered&quot; &quot;factor&quot; The behavior of both regular factors and ordered factors is the same in most cases. For instance, if we produce frequency tables or graphics, the result will be exactly the same: library(patchwork) ggformula::gf_bar(~nyha_1) + ggformula::gf_bar(~nyha_2) As commented above, the most important case where a regular or an ordered factor makes a difference is statistical modeling. In any other instance, it is unlikely that you need to define an ordered factor. Although we will not discuss the use of ordered factors in statistical models here, we want to make you aware of their existence, just in case you come across them. 2.3 Dates R has several data structures (object classes) and functions to work with dates and date-time values, providing the functionality one may possibly need, even to deal with data from different timezones. However, the lubridate package makes it easier to tackle many of the common tasks needed when processing date or date-time data in clinical studies. Because lubridate is not part of the tidyverse, we need to start by loading this package: library(lubridate) 2.3.1 Data structures for date and date-time values Let’s start by looking at the difference between dates and dete-time values. While dates identify calendar days, date-time values identify a point in time (to the nearest second). A couple of functions in lubridate are useful to see the difference between dates and date-time values: today(), which returns today’s date, and now(), which returns the current date-time: today() # today&#39;s date, a date value ## [1] &quot;2023-01-18&quot; now() # current time, a date-time value ## [1] &quot;2023-01-18 11:15:07 CET&quot; Note that the date-time value produced by now() specifies a timezone: CET (standing for Central European Time). By default, this will be your computer’s system timezone, but we can specify any timezone with argument tz, including UTC (corresponding to Coordinated Universal Time: now(tz = &quot;WET&quot;) # Western European Time (e.g., Canary Islands) ## [1] &quot;2023-01-18 10:15:07 WET&quot; now(tz = &quot;Pacific/Auckland&quot;) # City of New Zealand ## [1] &quot;2023-01-18 23:15:07 NZDT&quot; now(tz = &quot;UTC&quot;) # Coordinated Universal Time ## [1] &quot;2023-01-18 10:15:07 UTC&quot; Using class() we can see what are the types of objects used to store dates and date-times in R: x &lt;- today() y &lt;- now() class(x) ## [1] &quot;Date&quot; class(y) ## [1] &quot;POSIXct&quot; &quot;POSIXt&quot; As you see, dates are stored in Date objects, while date-times are stored as POSIXct (or POSIXt) objects. As we saw in previous sections, date-time values can be converted to date objects with as.Date(): as.Date(y) # date-time to date ## [1] &quot;2023-01-18&quot; class(as.Date(y)) ## [1] &quot;Date&quot; 2.3.2 Date and date-time formats By default, R uses the ISO 8601 standard notation to specify dates and date-times. However, alternative notations can be used by means of conversion specifications. The following table shows the most common symbols used in conversion specifications (for a more complete list, see ?strptime): Table 2.2: Symbols commonly used in Date and time conversion specifications Symbol Meaning %a abbreviated weekday name %A full weekday name %d day of the month %b abbreviated month name %B full month name %m month as number %y year without century %Y year with century %H hour %M minute %S second %T equivalent to %H:%M:%S These conversion specifications are used in a format string (e.g., \"%d %B %Y\"). Any other character included in the format string is interpreted literally. Function format() can be used to create a character string with the desired notation, as shown in these examples: format(x, format = &quot;%A %d %B %Y&quot;) ## [1] &quot;Wednesday 18 January 2023&quot; format(y, &quot;%d-%b-%Y, %T %Z&quot;) ## [1] &quot;18-Jan-2023, 11:15:07 CET&quot; Similarly, we can read dates from character vectors expressing calendar dates in an specific notation, by specifying it in the format argument of as.Date(): as.Date(&quot;05/03/2001&quot;, format = &quot;%d/%m/%Y&quot;) ## [1] &quot;2001-03-05&quot; 2.3.3 Reading dates Probably the most common problem with dates arises when reading data from external files in which calendar dates are indicated in strings using a specific notation (like “dd/mm/YYYY”). As we have seen in the previous section, these can be read and converted to date objects with as.Date(), provided the notation is consistent. However, inconsistent notation of dates is not uncommon, and cannot be handled by as.Date(). Fortunately, lubridate includes a family of functions that are able to parse dates from input vectors containing mixed date notations, provided the ordering of the date components is always the same. These functions are named according to the order of the date components. For instance, the following strings contain highly heterogeneous date notations, but the components are always in the same order (day, month and year), so that we can use function dmy() to read them: x &lt;- c(&quot;15-sep-03&quot;, &quot;24/08/1987&quot;, &quot;Tuesday 25 March 1958&quot;, &quot;02121957&quot;) dmy(x) ## [1] &quot;2003-09-15&quot; &quot;1987-08-24&quot; &quot;1958-03-25&quot; &quot;1957-12-02&quot; Similar functions are available for the remaining possible orderings: dym(), ymd(),ydm(),mdy(), ormyd()`. For intance: x &lt;- c(&quot;2003, 15-sep&quot;, &quot;1987 24/08&quot;, &quot;1950, Tuesday 25 March&quot;, &quot;19570212&quot;) ydm(x) ## [1] &quot;2003-09-15&quot; &quot;1987-08-24&quot; &quot;1950-03-25&quot; &quot;1957-12-02&quot; Other functions of this family allow to parse incomplete dates, like year and month or year and quarter providing the date of the first day in the interval: partial &lt;- c(&quot;2003-sep&quot;, &quot;1987.08&quot;, &quot;1950 March&quot;, &quot;1957.2&quot;) # year and month ym(partial) ## [1] &quot;2003-09-01&quot; &quot;1987-08-01&quot; &quot;1950-03-01&quot; &quot;1957-02-01&quot; partial &lt;- c(&quot;2003-3&quot;, &quot;1987.3&quot;, &quot;1950 1&quot;, &quot;1957.1&quot;) # year and quarter yq(partial) ## [1] &quot;2003-07-01&quot; &quot;1987-07-01&quot; &quot;1950-01-01&quot; &quot;1957-01-01&quot; Sometimes dates are split in diferent variables for the year, the month and the day. In such a case, a date can be formed with function make_date(), whose arguments are pretty obvious. Note that arguments can be numeric, character, or mixed types: x1 &lt;- &quot;2001&quot; x2 &lt;- 3 x3 &lt;- 5 the_date &lt;- make_date(year = x1, month = x2, day = x3) the_date ## [1] &quot;2001-03-05&quot; class(the_date) ## [1] &quot;Date&quot; 2.3.4 Getting date components When components have to be extracted from dates, functions with obvious names are available as shown in the following examples: bd &lt;- ydm(x) # a vector of birth dates bd ## [1] &quot;2003-09-15&quot; &quot;1987-08-24&quot; &quot;1950-03-25&quot; &quot;1957-12-02&quot; year(bd) # get the year ## [1] 2003 1987 1950 1957 month(bd) # get the month ## [1] 9 8 3 12 day(bd) # get the day of month ## [1] 15 24 25 2 wday(bd) # get the day of the week (1 to 7, starting on sunday) ## [1] 2 2 7 2   In the case of months and days of the week, argument label = TRUE will provide their names instead of numbers, either abbraviated (default) or full (if argument abbris set to FALSE). Nothe that in this case the result is a ordered factor: month(bd, label=TRUE) ## [1] Sep Aug Mar Dec ## 12 Levels: Jan &lt; Feb &lt; Mar &lt; Apr &lt; May &lt; Jun &lt; Jul &lt; Aug &lt; Sep &lt; ... &lt; Dec wday(bd, label=TRUE, abbr=FALSE) ## [1] Monday Monday Saturday Monday ## 7 Levels: Sunday &lt; Monday &lt; Tuesday &lt; Wednesday &lt; Thursday &lt; ... &lt; Saturday month(bd, label=TRUE) %&gt;% class() ## [1] &quot;ordered&quot; &quot;factor&quot; wday(bd, label=TRUE, abbr=FALSE) %&gt;% class() ## [1] &quot;ordered&quot; &quot;factor&quot; 2.3.5 A closer look to dates Up to now we have seen how dates look when printed to the console, but this is not what the are. In fact, dates are numeric vectors, as the following will reveal: x &lt;- as.Date(c(&quot;2003-09-15&quot;, &quot;1987-08-24&quot;, &quot;1950-03-25&quot;, &quot;1957-12-02&quot;)) xx &lt;- unclass(x) xx ## [1] 12310 6444 -7222 -4413 class(xx) ## [1] &quot;numeric&quot; As you see, the actual contents is 12310, 6444, -7222, -4413, and this is the number of days elapsed since an arbitrary origin (set to the first of January 1970). Thus, dates are stored as the number of days elapsed since the origin, as illustrated in figure @ref(fig:dates_internal) (note that dates before the origin are stored as negative numbers). (#fig:dates_internal)Dates as stored in R Package lubridate includes the date-time object origin, so that we can see what’s the origin: as.Date(origin) ## [1] &quot;1970-01-01&quot;   Now, we can easily verify that the values 12310, 6444, -7222, -4413 stored in date x above are nothing but the numbers of days elapsed since the origin: x - as.Date(origin) ## Time differences in days ## [1] 12310 6444 -7222 -4413 Or equivalently, we may add this number of days to the origin and we will get the dates in x. as.Date(origin) + xx ## [1] &quot;2003-09-15&quot; &quot;1987-08-24&quot; &quot;1950-03-25&quot; &quot;1957-12-02&quot; In summary, a date object is a numeric vector containing whole numbers (the number of days elapsed since the 1st Jan 1970), that have been given the class atribute Date. He is a demo: x &lt;- 1:7 x ## [1] 1 2 3 4 5 6 7 class(x) ## [1] &quot;integer&quot; class(x) &lt;- &quot;Date&quot; x ## [1] &quot;1970-01-02&quot; &quot;1970-01-03&quot; &quot;1970-01-04&quot; &quot;1970-01-05&quot; &quot;1970-01-06&quot; ## [6] &quot;1970-01-07&quot; &quot;1970-01-08&quot; 2.3.6 Shifting dates Sometimes we may need to create a sequence of dates from a starting point in time. For instance, consider a study in which monthly visits are planned after enrollment of a patient. If we want to evaluate the difference between planned and actual visit dates, we need to create the sequence of planned dates to compare them to actual dates. If visit intervals are defined by a fixed number of days (say, 30 days) we just need to add this number to the enrollment date. enrollment &lt;- as.Date(&quot;2022-01-01&quot;) enrollment ## [1] &quot;2022-01-01&quot; intervals &lt;- 30 * 0:6 intervals ## [1] 0 30 60 90 120 150 180 enrollment + intervals ## [1] &quot;2022-01-01&quot; &quot;2022-01-31&quot; &quot;2022-03-02&quot; &quot;2022-04-01&quot; &quot;2022-05-01&quot; ## [6] &quot;2022-05-31&quot; &quot;2022-06-30&quot;   Alternatively, we might prefer to set intervals as natural months, but this is not straightforward since the number of days in a month is not constant. Fortunately, lubridate has a family of functions that create natural periods like months, weeks, or years. These functions take the name of the periods they create, and allow to indicate the number of periods want to create as a numeric vector: enrollment + months(0:6) ## [1] &quot;2022-01-01&quot; &quot;2022-02-01&quot; &quot;2022-03-01&quot; &quot;2022-04-01&quot; &quot;2022-05-01&quot; ## [6] &quot;2022-06-01&quot; &quot;2022-07-01&quot; enrollment + years(0:5) ## [1] &quot;2022-01-01&quot; &quot;2023-01-01&quot; &quot;2024-01-01&quot; &quot;2025-01-01&quot; &quot;2026-01-01&quot; ## [6] &quot;2027-01-01&quot; If the addition of periods results in a non-existing date, these functions will return NA: enrollment &lt;- as.Date(&quot;2001-01-31&quot;) enrollment + months(0:6) ## [1] &quot;2001-01-31&quot; NA &quot;2001-03-31&quot; NA &quot;2001-05-31&quot; ## [6] NA &quot;2001-07-31&quot;   To avoid this, the operator %m+% should be used: enrollment %m+% months(0:6) ## [1] &quot;2001-01-31&quot; &quot;2001-02-28&quot; &quot;2001-03-31&quot; &quot;2001-04-30&quot; &quot;2001-05-31&quot; ## [6] &quot;2001-06-30&quot; &quot;2001-07-31&quot;   And similarly for leap years: leap_year(2020) ## [1] TRUE as.Date(&quot;2020-02-29&quot;) + years(0:5) ## [1] &quot;2020-02-29&quot; NA NA NA &quot;2024-02-29&quot; ## [6] NA as.Date(&quot;2020-02-29&quot;) %m+% years(0:5) ## [1] &quot;2020-02-29&quot; &quot;2021-02-28&quot; &quot;2022-02-28&quot; &quot;2023-02-28&quot; &quot;2024-02-29&quot; ## [6] &quot;2025-02-28&quot; 2.3.7 Intervals Intervals are timespans bounded by start and end dates. Intervals can be created with functioninterval(), or with the operator %--%, from either Date objects or strings in ISO 8601 format: birth &lt;- as.Date(&quot;2001-03-05&quot;) interval(start = birth, end = today()) # from Dates ## [1] 2001-03-05 UTC--2023-01-18 UTC birth %--% today() # using %--% ## [1] 2001-03-05 UTC--2023-01-18 UTC &quot;2001-03-05&quot; %--% today() # from ISO 8601 strings ## [1] 2001-03-05 UTC--2023-01-18 UTC We can use intervals in several ways. For instance, we can use them to compute age at enrollment. To this end, we divide the interval between birth and enrollment dates by a period of one year. If we want to express age in completed years (as we usually do), we truncate the result : birth %--% today() / years(1) # age in years ## [1] 21.87397 trunc(birth %--% today() / years(1)) # age in complete years ## [1] 21 Another interesting use of intervals is the detection of overlapping intervals. For instance, we may want to know if a concomitant medication was taken during a specific phase of a clinical trial. This can be done with function int_overlaps(), passing it the two intervals as arguments: treatment_phase &lt;- interval(&quot;2021-01-01&quot;, &quot;2021-03-31&quot;) steroids &lt;- interval(&quot;2020-12-15&quot;, &quot;2020-12-31&quot;) statins &lt;- interval(&quot;2021-02-15&quot;, today()) int_overlaps(treatment_phase, steroids) ## [1] FALSE int_overlaps(treatment_phase, statins) ## [1] TRUE Last, intervals can be created also from a sequence of dates stored in a vector, with function int_diff()`. This will create intervals defined by two consecutive visits: visits &lt;- enrollment %m+% months(0:6) visits ## [1] &quot;2001-01-31&quot; &quot;2001-02-28&quot; &quot;2001-03-31&quot; &quot;2001-04-30&quot; &quot;2001-05-31&quot; ## [6] &quot;2001-06-30&quot; &quot;2001-07-31&quot; int_diff(visits) ## [1] 2001-01-31 UTC--2001-02-28 UTC 2001-02-28 UTC--2001-03-31 UTC ## [3] 2001-03-31 UTC--2001-04-30 UTC 2001-04-30 UTC--2001-05-31 UTC ## [5] 2001-05-31 UTC--2001-06-30 UTC 2001-06-30 UTC--2001-07-31 UTC 2.4 Dataframe variables In previous sections we have illustrated how to use of several functions to work with strings, factors and dates. To keep the examples code as simple as possible, we illustrated their use on vectors. However, when processing real data, it is very likely that we need to create new variables in a dataframe, which can be achieved with the mutate() function in dplyr. Any of the functions we have discussed can be used within a mutate() statement. For instance, when reading the DISETAHE MS Excel file, the two variables containing dates (data_xtract_dt and ah_dx_dt) are date-time objects in the resulting dataframe: library(readxl) demo &lt;- read_excel(&quot;./data/hta.xlsx&quot;, sheet = &quot;data&quot;) %&gt;% select(pid, data_xtract_dt, region, age, sex, ah_dx_dt) class(demo$data_xtract_dt) ## [1] &quot;POSIXct&quot; &quot;POSIXt&quot; class(demo$ah_dx_dt) ## [1] &quot;POSIXct&quot; &quot;POSIXt&quot; But when these variables are printed, we see that the time value non-informative (it is always 00:00:00): head(demo) ## # A tibble: 6 × 6 ## pid data_xtract_dt region age sex ah_dx_dt ## &lt;dbl&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt; ## 1 11 2003-03-15 00:00:00 6 52 1 1998-01-01 00:00:00 ## 2 15 2003-03-15 00:00:00 6 57 2 1997-01-01 00:00:00 ## 3 20 2003-05-13 00:00:00 1 62 1 2003-04-10 00:00:00 ## 4 24 2003-05-27 00:00:00 10 69 2 1993-01-01 00:00:00 ## 5 33 2003-05-28 00:00:00 10 70 2 1994-01-01 00:00:00 ## 6 37 2003-06-14 00:00:00 9 64 2 1995-04-07 00:00:00   To convert these variables to the simpler and more convenient Date class, the as.Date() function may be used in a mutate() statement: demo %&gt;% mutate(data_xtract_dt = as.Date(data_xtract_dt), ah_dx_dt = as.Date(ah_dx_dt)) ## # A tibble: 500 × 6 ## pid data_xtract_dt region age sex ah_dx_dt ## &lt;dbl&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; ## 1 11 2003-03-15 6 52 1 1998-01-01 ## 2 15 2003-03-15 6 57 2 1997-01-01 ## 3 20 2003-05-13 1 62 1 2003-04-10 ## 4 24 2003-05-27 10 69 2 1993-01-01 ## 5 33 2003-05-28 10 70 2 1994-01-01 ## 6 37 2003-06-14 9 64 2 1995-04-07 ## 7 50 2003-06-16 2 55 2 NA ## 8 83 2004-03-15 5 64 1 1981-01-01 ## 9 91 2004-03-15 5 57 1 1996-01-01 ## 10 114 2004-04-05 5 73 2 1991-06-04 ## # … with 490 more rows While this is fine because we need to convert two variables only, it may be cumbersome when many variables have to be converted. 2.4.1 Processing several variables at once When several variables have to be processed the same way, a better approach is to use across() within mutate(). The across() function takes two arguments. This first argument indicates the variables to be processed, and the second argument specifies the function to be applied to these variables: demo %&gt;% mutate(across(c(data_xtract_dt, ah_dx_dt), as.Date)) ## # A tibble: 500 × 6 ## pid data_xtract_dt region age sex ah_dx_dt ## &lt;dbl&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; ## 1 11 2003-03-15 6 52 1 1998-01-01 ## 2 15 2003-03-15 6 57 2 1997-01-01 ## 3 20 2003-05-13 1 62 1 2003-04-10 ## 4 24 2003-05-27 10 69 2 1993-01-01 ## 5 33 2003-05-28 10 70 2 1994-01-01 ## 6 37 2003-06-14 9 64 2 1995-04-07 ## 7 50 2003-06-16 2 55 2 NA ## 8 83 2004-03-15 5 64 1 1981-01-01 ## 9 91 2004-03-15 5 57 1 1996-01-01 ## 10 114 2004-04-05 5 73 2 1991-06-04 ## # … with 490 more rows In the first argument, helper functions can be used just like with select(): demo %&gt;% mutate(across(ends_with(&quot;dt&quot;), as.Date)) ## # A tibble: 500 × 6 ## pid data_xtract_dt region age sex ah_dx_dt ## &lt;dbl&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; ## 1 11 2003-03-15 6 52 1 1998-01-01 ## 2 15 2003-03-15 6 57 2 1997-01-01 ## 3 20 2003-05-13 1 62 1 2003-04-10 ## 4 24 2003-05-27 10 69 2 1993-01-01 ## 5 33 2003-05-28 10 70 2 1994-01-01 ## 6 37 2003-06-14 9 64 2 1995-04-07 ## 7 50 2003-06-16 2 55 2 NA ## 8 83 2004-03-15 5 64 1 1981-01-01 ## 9 91 2004-03-15 5 57 1 1996-01-01 ## 10 114 2004-04-05 5 73 2 1991-06-04 ## # … with 490 more rows If the function to be applied needs some arguments, they can be passed as further arguments to across(). For instance, suppose we want to define factors for all treatment variables in the DISETAHE study. Because all of them are coded the same way, the factor definition is identical for all: treatments &lt;- read_excel(&quot;./data/hta.xlsx&quot;, sheet = &quot;data&quot;) %&gt;% select(pid, lmr:other) treatments %&gt;% mutate(lmr = factor(lmr, levels = 1:2, labels = c(&quot;yes&quot;, &quot;no&quot;)), bb = factor(bb, levels = 1:2, labels = c(&quot;yes&quot;, &quot;no&quot;)), diur = factor(diur, levels = 1:2, labels = c(&quot;yes&quot;, &quot;no&quot;)), acei = factor(acei, levels = 1:2, labels = c(&quot;yes&quot;, &quot;no&quot;)), arb = factor(arb, levels = 1:2, labels = c(&quot;yes&quot;, &quot;no&quot;)), cbb = factor(cbb, levels = 1:2, labels = c(&quot;yes&quot;, &quot;no&quot;)), ab = factor(ab, levels = 1:2, labels = c(&quot;yes&quot;, &quot;no&quot;)), other = factor(other, levels = 1:2, labels = c(&quot;yes&quot;, &quot;no&quot;))) ## # A tibble: 500 × 9 ## pid lmr bb diur acei arb cbb ab other ## &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; ## 1 11 yes yes no no no no no no ## 2 15 yes no no yes no no no no ## 3 20 yes no no no no no no no ## 4 24 yes no yes no no no no no ## 5 33 yes no yes no no no no no ## 6 37 yes no yes no yes no no no ## 7 50 no no no no no no no no ## 8 83 yes no no no no no no yes ## 9 91 yes no no yes no no no no ## 10 114 yes no yes no yes no no no ## # … with 490 more rows Using across(), we need to pass the factor function as second argument, and the levels and labels arguments as further arguments: treatments %&gt;% mutate(across(lmr:other, factor, levels = 1:2, labels = c(&quot;yes&quot;, &quot;no&quot;))) ## # A tibble: 500 × 9 ## pid lmr bb diur acei arb cbb ab other ## &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; ## 1 11 yes yes no no no no no no ## 2 15 yes no no yes no no no no ## 3 20 yes no no no no no no no ## 4 24 yes no yes no no no no no ## 5 33 yes no yes no no no no no ## 6 37 yes no yes no yes no no no ## 7 50 no no no no no no no no ## 8 83 yes no no no no no no yes ## 9 91 yes no no yes no no no no ## 10 114 yes no yes no yes no no no ## # … with 490 more rows Sometimes we may want to identify the variables to be processed by their type. For instance, suppose that diagnostic variables had been defined as logical variables, as is the case in dataframe diag below: ## # A tibble: 500 × 6 ## pid age sex dx_dm dx_dyslip dx_lvh ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; ## 1 11 52 1 TRUE TRUE TRUE ## 2 15 57 2 TRUE TRUE TRUE ## 3 20 62 1 TRUE TRUE TRUE ## 4 24 69 2 TRUE FALSE TRUE ## 5 33 70 2 TRUE FALSE TRUE ## 6 37 64 2 FALSE TRUE TRUE ## 7 50 55 2 TRUE NA TRUE ## 8 83 64 1 TRUE FALSE TRUE ## 9 91 57 1 TRUE FALSE TRUE ## 10 114 73 2 FALSE FALSE TRUE ## # … with 490 more rows Suppose we want to convert them to numeric with as.numeric(). This can be done using where() in the first argument of across() to identify all variables being of logical type, and as.numeric as the second argument: diag %&gt;% mutate(across(where(is.logical), as.numeric)) ## # A tibble: 500 × 6 ## pid age sex dx_dm dx_dyslip dx_lvh ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 11 52 1 1 1 1 ## 2 15 57 2 1 1 1 ## 3 20 62 1 1 1 1 ## 4 24 69 2 1 0 1 ## 5 33 70 2 1 0 1 ## 6 37 64 2 0 1 1 ## 7 50 55 2 1 NA 1 ## 8 83 64 1 1 0 1 ## 9 91 57 1 1 0 1 ## 10 114 73 2 0 0 1 ## # … with 490 more rows If the operation we need to perform is complex and there is no single function to do it, we can use an expression preceeded by ~, and use .x to indicate where the variable in across is used. For example, supose we want to recode all drug treatments as 1 or 0 instead of 1 or 2 (for yes or no, respectively). This will work: treatments %&gt;% mutate(across(bb:other, ~ ifelse(.x == 1, 1, 0))) ## # A tibble: 500 × 9 ## pid lmr bb diur acei arb cbb ab other ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 11 1 1 0 0 0 0 0 0 ## 2 15 1 0 0 1 0 0 0 0 ## 3 20 1 0 0 0 0 0 0 0 ## 4 24 1 0 1 0 0 0 0 0 ## 5 33 1 0 1 0 0 0 0 0 ## 6 37 1 0 1 0 1 0 0 0 ## 7 50 2 0 0 0 0 0 0 0 ## 8 83 1 0 0 0 0 0 0 1 ## 9 91 1 0 0 1 0 0 0 0 ## 10 114 1 0 1 0 1 0 0 0 ## # … with 490 more rows Resources For more on strings and regex, look at the vignettes of the stringr package. You may see them by running the following code in the R console: vignette(\"stringr\") vignette(\"regular-expressions\") Of course, there is a stringr R cheat sheet! Try this nice interactive tutorial to practice your regex. For a comparison of stringr and base R functions, see here. Package translateR provides easy access to the Google and Microsoft APIs for languaje detection and translation. If you are interested in fuzzy matching of strings, look at the fuzzywuzzyR and stringdist packages. If you have ICD-9 or ICD-10 codes and need to compute comorbidity indices (such as the Charlson index), have a look to package icd. For more on factors, look at the vignette of the forcats package by running the following code in the R console: vignette(\"forcats\"), or see (this tutorial)[https://www.r-bloggers.com/2020/06/working-with-factors-in-r-tutorial-forcats-package/]. For more on dates and times, see this book chapter, or this comprehensive tutorial. Exercises From the following character vector of NYHA classes, use str_extract() with regular expressions to get two character vectors: one containing roman numerals only, and another one containing the text description, starting with a capital letter (the dots should be removed, as well any leading, trailing or extra white space). nyha &lt;- c(&quot;I. no limitation&quot;, &quot;II. mild symptoms &quot;, &quot;III. Marked symptoms&quot;, &quot;IV. severe limitations&quot;) With the given vector on antecedents of four patients: antec &lt;- c(&quot;Asthma&quot;, &quot;DM and AHT&quot;, &quot;DM, AHT and pneumonia&quot;, &quot;AHT + pneumonia&quot;) Use str_view_all() to test a regular expression detecting all separators between different antecedents of the same patient(and, , or +). Use str_replace_all() to homogenize separators between antecedents using always + (e.g., “DM + AHT + pneumonia”). From the vector you got in the previous question, can you compute a numeric vector showing the number of antecedents for each patient? Use the button to download a dataset on medical antecedents of 21 patients. After reading the data into dataframe d, run the code below to detect all diabetic patients, and then address the following tasks. Download antecedents data d$antecedent %&gt;% str_to_lower() %&gt;% str_view(pattern = &quot;diabet.s|diabetic|dm&quot;) Copy-paste the previous code and adapt the regexp in pattern to detect all patients with arterial hypertension. Do the same to detect all patients with bronchial asthma. Use the previous regexp patterns in str_detect() to create three new logical variables in dataframe d: dm, aht, and ba, as indicators of diabetes mellitus, arterial hypertension and bronchial asthma, respectively. Download the doses data set, read it, and produce the bar chart shown below. Download doses data On the same data, use fct_collapse() to define doses as “low” (25 or 50 mg), “medium” (100 mg) or “high” (150 or 200 mg), and produce the following bar chart: The following code reads the DISETAHE study data, selects drug class variables, verticalises them, and filters patients that took each drug class. From the resulting dataframe drug_classes, reproduce the bar chart shown below (with identical descriptors for drug classes). drug_classes &lt;- readxl::read_excel(&quot;./data/hta.xlsx&quot;, sheet = &quot;data&quot;) %&gt;% select(pid, bb:other) %&gt;% pivot_longer(bb:other, names_to = &quot;drug_class&quot;, values_to = &quot;value&quot;) %&gt;% filter(value == 1) %&gt;% arrange(pid, drug_class) Create a dataframe with the CIP codes provided below, and use a mutate() statement to compute additional variables sex, dob and age: cip = the CIP code. sex = a factor with labels “male” and “female”. dob = the date of birth; this should be a Date object. age = the patient’s age as of 2022-01-01. cip &lt;- c(&quot;FEGA0720525000&quot;, &quot;ROMA1690913000&quot;, &quot;PEJI0010503&quot;) Repeat the previous exercise after adding this new CIP to the cip vector: “ALCO0580325000”. The date of enrollment of a patient in a study was “2016-01-01”. In this study, follow-up visits should be conducted at 1, 3 and 6 months and 1 year after enrollment, and yearly thereafter up to 5 years. What should be the dates of follow-up visits assuming 30-day months? And what would they be using natural month intervals? Is there any saturday or sunday among them? Use across() in a mutate() statement to recode all yes/no variables in the DISETAHE dataset so that they take values 1 (for yes) or 0 (for no). "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
